{"version":3,"sources":["dragular.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","dragularDirective","dragularService","angular","directive","dragular","restrict","link","$scope","iElm","iAttrs","tryJson","json","JSON","parse","e","drake","options","$eval","containersModel","dynamicModelAttribute","$watch","dragularModel","newVal","sanitizeContainersModel","dragularNameSpace","nameSpace","split","dragularOnInit","onInit","$inject","shared","classesCache","containersCtx","containers","mirror","source","item","copy","sourceItem","sourceModel","sourceFilteredModel","target","targetCtx","targetModel","lastDropTarget","offsetX","offsetY","moveX","moveY","offsetXr","offsetYb","clientX","clientY","mirrorWidth","mirrorHeight","initialSibling","currentSibling","initialIndex","currentIndex","tempModel","dragOverEvents","lastElementBehindCursor","grabbed","$rootScope","$compile","service","arg0","arg1","Array","isArray","o","scope","processServiceArguments","arguments","length","isElement","initialContainers","document","querySelectorAll","copyOptions","extendOptions","tmp","extend","defaultOptions","classes","defaultClasses","eventNames","defaultEventNames","processOptionsObject","boundingBox","makeArray","containersFilteredModel","forEach","len","shLen","getContainersModel","fm","registerEvents","remove","op","regEvent","docElm","release","container","grab","name","eventName","doc","createEvent","initEvent","createEventObject","eventType","whichMouseButton","metaKey","ctrlKey","context","canStart","eventualMovements","type","isInput","focus","preventDefault","ungrab","dragging","originalEvent","getCoord","elementBehindCursor","getElementBehindPoint","dropTarget","findDropTarget","g","copySortSource","drop","removeOnSpill","cancel","fireEvent","dragularrelease","$emit","isContainer","el","indexOf","isContainerModel","opt","removeContainers","all","$applyAsync","changes","index","splice","startBecauseMouseMoved","movements","preventGrabbed","destroy","ignoreInputTextSelection","elementFromPoint","end","start","direction","getParent","parent","parentNode","parentHeight","offsetHeight","parentWidth","offsetWidth","childHeight","clientHeight","childWidth","clientWidth","offset","getOffset","left","top","right","bottom","renderMirrorImage","addClass","transit","style","drag","handle","invalid","moves","nextEl","manualStart","cloneNode","dragularcloned","containerIndex","domIndexOf","dragulardrag","afterDrop","compileItemOnDrop","element","content","removeChild","insertBefore","cleanup","isInitialPlacement","dragularcancel","dragulardrop","dropIndex","dropElmModel","dontCopyModel","dragularremove","revert","reverts","revertOnSpill","initial","removeMirrorImage","rmClass","spillOut","dragularout","dragulardragend","s","sibling","accepted","immediate","getImmediateChild","reference","getReference","getTargetCtx","accepts","isContainerAccepts","canBeAccepted","moved","spillOver","pageX","pageY","offsetBox","x","y","lockY","lockX","changed","dragularenter","dragularleave","dragularshadow","hide","scrollContainer","before","scrollTop","deltaY","stopPropagation","rect","getBoundingClientRect","width","height","getRectWidth","getRectHeight","mirrorContainer","appendChild","body","unselectable","outside","children","horizontal","inside","resolve","after","point","state","className","getBool","dragularover","never","getEmptyObject","always","fn","touch","mouseup","mousedown","mousemove","pointers","microsoft","$el","addEventListener","opConvert","on","off","passive","navigator","pointerEnabled","msPointerEnabled","startIndex","prototype","slice","touches","which","undefined","buttons","button","getScroll","scrollProp","offsetProp","window","scrollLeft","manually","nextSibling","nodeType","nextElementSibling","obj","HTMLElement","nodeName","lookupClass","cached","lastIndex","RegExp","current","test","replace","trim","getEventHost","targetTouches","changedTouches","coord","host","missMap","tagName","isEditable","contentEditable","child","extra","dispatchEvent","prop","args","isFunction","apply","documentElement","cleanEnviroment"],"mappings":"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","file":"dragular.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* global angular */\n\t'use strict';\n\tvar dragularDirective = __webpack_require__(1);\n\tvar dragularService = __webpack_require__(2);\n\n\t/**\n\t * Dragular 4.4.0 by Luckylooke https://github.com/luckylooke/dragular\n\t * Angular version of dragula https://github.com/bevacqua/dragula\n\t */\n\tmodule.exports = 'dragularModule';\n\n\tangular\n\t  .module('dragularModule', [])\n\t  .factory('dragularService', dragularService)\n\t  .directive('dragular', dragularDirective);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\t/**\n\t * dragular Directive by Luckylooke https://github.com/luckylooke/dragular\n\t * Angular version of dragula https://github.com/bevacqua/dragula\n\t */\n\n\tvar dragular = function (dragularService) {\n\t  return {\n\t    restrict: 'A',\n\t    link: function($scope, iElm, iAttrs) {\n\n\t      var drake,\n\t        options = $scope.$eval(iAttrs.dragular) || tryJson(iAttrs.dragular) || {};\n\n\t      function tryJson(json) {\n\t        try { // I dont like try catch solutions but I havent find sattisfying way of chcecking json validity.\n\t          return JSON.parse(json);\n\t        } catch (e) {\n\t          return undefined;\n\t        }\n\t      }\n\n\t      if(options && options.containersModel && typeof options.containersModel === 'string'){\n\t        options.containersModel = $scope.$eval(options.containersModel);\n\t      }\n\n\t      if(options && options.dynamicModelAttribute){\n\t        // watch for model changes\n\t        $scope.$watch(function () {\n\t          return $scope.$eval(iAttrs.dragularModel);\n\t        }, function (newVal) {\n\t          if(newVal){\n\t            drake.containersModel = drake.sanitizeContainersModel($scope.$eval(newVal));\n\t          }\n\t        });\n\t      }else if(iAttrs.dragularModel){\n\t        // bind once and keep reference\n\t        options.containersModel = $scope.$eval(iAttrs.dragularModel);\n\t      }\n\n\t      if(iAttrs.dragularNameSpace){\n\t        options.nameSpace = iAttrs.dragularNameSpace.split(' ');\n\t      }\n\n\t      if(iAttrs.dragularOnInit){\n\t        options.onInit = $scope.$eval(iAttrs.dragularOnInit);\n\t      }\n\n\t      drake = dragularService(iElm[0], options);\n\t    }\n\t  };\n\t};\n\n\tdragular.$inject = ['dragularService'];\n\n\tmodule.exports = dragular;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/* global angular */\n\t'use strict';\n\n\t/**\n\t * dragular Service by Luckylooke https://github.com/luckylooke/dragular\n\t * Angular version of dragula https://github.com/bevacqua/dragula\n\t */\n\n\tvar shared = { // sahred object between all service instances\n\t  classesCache: {}, // classes lookup cache\n\t  containersCtx: {}, // containers model\n\t  containers: {}, // containers\n\t  mirror: null, // mirror image\n\t  source: null, // source container\n\t  item: null, // item being dragged\n\t  copy: null, // copy flag\n\t  sourceItem: null, // item originaly dragged if copy is enabled\n\t  sourceModel: null, // source container model\n\t  sourceFilteredModel: null, // source container filtered model if relevant\n\t  target: null, // droppable container under drag item\n\t  targetCtx: null, // target container context\n\t  targetModel: null, // target container model\n\t  lastDropTarget: null, // last container item was over\n\t  offsetX: null, // reference x\n\t  offsetY: null, // reference y\n\t  moveX: null, // reference move x\n\t  moveY: null, // reference move y\n\t  offsetXr: null, // reference x right for boundingBox feature\n\t  offsetYb: null, // reference y bottom for boundingBox feature\n\t  clientX: null, // cache client x, init at grab, update at drag\n\t  clientY: null, // cache client y, init at grab, update at drag\n\t  mirrorWidth: null, // mirror width for boundingBox feature\n\t  mirrorHeight: null, // mirror height for boundingBox feature\n\t  initialSibling: null, // reference sibling when grabbed\n\t  currentSibling: null, // reference sibling now\n\t  initialIndex: null, // reference model index when grabbed\n\t  currentIndex: null, // reference model index now\n\t  tempModel: null, // if o.isContainer is used, model can be provided as well, it is temporary saved here during drags\n\t  dragOverEvents: {}, // drag over events fired on element behind cursor\n\t  lastElementBehindCursor: null, // last element behind cursor\n\t  grabbed: null // holds mousedown context until first mousemove\n\t};\n\n\tvar dragularService = function ($rootScope, $compile) {\n\t  // abbreviations\n\t  var doc = document,\n\t      docElm = doc.documentElement;\n\n\t  // clean common/shared objects\n\t  service.cleanEnviroment = function cleanEnviroment() {\n\t    shared.classesCache = {};\n\t    shared.containersCtx = {};\n\t    shared.containers = {};\n\t    shared.mirror = undefined;\n\t  };\n\n\t  service.shared = shared;\n\n\t  return service;\n\n\t  // service definition\n\t  function service(arg0, arg1) {\n\t    var initialContainers = arg0 || [],\n\t      options = arg1 || {},\n\t      o, // shorthand for options\n\t      g = getBool, // shorthand for getBool\n\t      // defaults\n\t      defaultClasses = {\n\t        mirror: 'gu-mirror',\n\t        hide: 'gu-hide',\n\t        unselectable: 'gu-unselectable',\n\t        transit: 'gu-transit'\n\t      },\n\t      defaultEventNames = {\n\t        // drag-over DOM events\n\t        dragularenter: 'dragularenter',\n\t        dragularleave: 'dragularleave',\n\t        dragularrelease: 'dragularrelease',\n\t        // $scope events\n\t        dragularcloned: 'dragularcloned',\n\t        dragulardrag: 'dragulardrag',\n\t        dragularcancel: 'dragularcancel',\n\t        dragulardrop: 'dragulardrop',\n\t        dragularremove: 'dragularremove',\n\t        dragulardragend: 'dragulardragend',\n\t        dragularshadow: 'dragularshadow',\n\t        dragularover: 'dragularover',\n\t        dragularout: 'dragularout'\n\t      },\n\t      defaultOptions = { // options with defaults\n\t        copyOptions: false, // copy options object when provided\n\t        classes: defaultClasses, // classes used by dragular\n\t        eventNames: defaultEventNames, // event names used by dragular\n\t        containers: false, // initial containers provided via options object (are provided via parameter by default)\n\t        containersModel: false, // if provided, model will be synced with DOM\n\t        containersFilteredModel: false, // if provided, dragular will handle filtered model cases\n\t        isContainer: never, // potential target can be forced to be container by custom logic\n\t        isContainerModel: getEmptyObject, // if isContainer function is provided, you can provide also respective model\n\t        isContainerAccepts: always, // if isContainer function is provided, you can provide also respective accept function\n\t        moves: always, // can drag start?\n\t        accepts: always, // can target accept dragged item? (target context used)\n\t        canBeAccepted: always, // can be dragged item accepted by target? (source context used)\n\t        copy: false, // dragged item will be copy of source? flag or function\n\t        copySortSource: false, // enable sorting in source when copying item\n\t        dontCopyModel: false, // dont make copy of model when coping item (#61)\n\t        invalid: never, // target (in)validity function\n\t        revertOnSpill: false, // item returns to original place\n\t        removeOnSpill: false, // item will be removed if not placed into valid target\n\t        lockX: false, // lock movement into x-axis\n\t        lockY: false, // lock movement into y-axis\n\t        boundingBox: false, // lock movement inside this element boundaries\n\t        mirrorContainer: doc.body, // element for appending mirror\n\t        ignoreInputTextSelection: true, // text selection in inputs wont be considered as drag\n\t        compileItemOnDrop: false,\n\t        onInit: false // function callback called after dragular initialisation and providing drake as first argument\n\t      },\n\t      drake = {\n\t        containers: shared.containers,\n\t        containersCtx: shared.containersCtx,\n\t        sanitizeContainersModel: sanitizeContainersModel,\n\t        isContainer: isContainer,\n\t        start: manualStart,\n\t        end: end,\n\t        cancel: cancel,\n\t        remove: remove,\n\t        destroy: destroy,\n\t        dragging: false\n\t      };\n\n\t    processServiceArguments(); // both arguments (containers and options) are optional, this function handle this\n\t    extendOptions();\n\t    processOptionsObject();\n\t    registerEvents();\n\t    \n\t    if (o.onInit){\n\t       o.onInit(drake, o);\n\t    }\n\n\t    return drake;\n\n\t    // Function definitions: ==============================================================================================================\n\t    // Initial functions: -----------------------------------------------------------------------------------------------------------------\n\n\t    function sanitizeContainersModel(containersModel) {\n\t      if (typeof containersModel === 'function') {\n\t        return containersModel;\n\t      } else if (Array.isArray(containersModel)) {\n\t          //                  |-------- is 2D array? -----------|\n\t          return Array.isArray(containersModel[0]) ? containersModel : [containersModel];\n\t      } else if (typeof containersModel === 'string' && o.scope) {\n\t          return function () {\n\t              return o.scope[containersModel];\n\t          };\n\t      } else {\n\t        return [];\n\t      }\n\t    }\n\n\t    function processServiceArguments(){\n\t      if (arguments.length === 1 && // if there is only one argument we need to distinguish if it is options object or container(s) reference\n\t          !Array.isArray(arg0) && // array of containers elements\n\t          !angular.isElement(arg0) && // one container element\n\t          !arg0[0] && // array-like object with containers elements\n\t          typeof arg0 !== 'string') { // selector\n\t        // then arg0 is options object\n\t        options = arg0 || {};\n\t        initialContainers = []; // containers are not provided on init\n\t      } else if (typeof arg0 === 'string') {\n\t        initialContainers = document.querySelectorAll(arg0);\n\t      }\n\t      o = options.copyOptions ? angular.copy(options) : options;\n\t    }\n\n\t    function extendOptions(){\n\t      var tmp = angular.extend({}, defaultOptions, o); // tmp for keeping defaults untouched\n\t      angular.extend(o, tmp); // merge defaults back into options\n\t      if (o.classes){\n\t        tmp = angular.extend({}, defaultClasses, o.classes);\n\t        angular.extend(o.classes, tmp);\n\t      }\n\t      if (o.eventNames){\n\t        tmp = angular.extend({}, defaultEventNames, o.eventNames);\n\t        angular.extend(o.eventNames, tmp);\n\t      }\n\t    }\n\n\t    function processOptionsObject(){\n\t      // bounding box must be pure DOM element, not jQuery wrapper or something else..\n\t      if (!isElement(o.boundingBox)) {\n\t        o.boundingBox = false;\n\t      }\n\n\t      // initial containers provided via options are higher priority then by parameter\n\t      if (o.containers){\n\t        initialContainers = o.containers;\n\t      }\n\t      // sanitize initialContainers\n\t      initialContainers = makeArray(initialContainers);\n\t      o.initialContainers = initialContainers;\n\n\t      // sanitize o.containersModel\n\t      o.containersModel = sanitizeContainersModel(o.containersModel);\n\n\t      // sanitize o.containersFilteredModel\n\t      if (Array.isArray(o.containersFilteredModel)) {\n\t        //                  |-------- is 2D array? -----------|\n\t        o.containersFilteredModel = Array.isArray(o.containersFilteredModel[0]) ? o.containersFilteredModel : [o.containersFilteredModel];\n\t      } else {\n\t        o.containersFilteredModel = [];\n\t      }\n\n\t      // feed containers groups and optionaly do same for models\n\t      if (!o.nameSpace) {\n\t        o.nameSpace = ['dragularCommon'];\n\t      }\n\t      if (!Array.isArray(o.nameSpace)) {\n\t        o.nameSpace = [o.nameSpace];\n\t      }\n\t      o.nameSpace.forEach(function eachNameSpace(nameSpace) {\n\t        if (!shared.containers[nameSpace]) {\n\t          shared.containers[nameSpace] = [];\n\t          shared.containersCtx[nameSpace] = [];\n\t        }\n\t        var len = initialContainers.length,\n\t          shLen = shared.containers[nameSpace].length;\n\t        for (var i = 0; i < len; i++) {\n\t          shared.containers[nameSpace][i + shLen] = initialContainers[i];\n\t          shared.containersCtx[nameSpace][i + shLen] = {\n\t            o: o,\n\t            m: getContainersModel(o)[i], // can be undefined\n\t            fm: o.containersFilteredModel[i] // can be undefined\n\t          };\n\t        }\n\t      });\n\t    }\n\n\t    function registerEvents(remove) {\n\t      var op = remove ? 'off' : 'on';\n\t      regEvent(docElm, op, 'mouseup', release);\n\n\t      initialContainers.forEach(function addMouseDown(container) {\n\t        regEvent(container, 'on', 'mousedown', grab);\n\t      });\n\n\t      if (!remove){ // create dragular DOM events\n\t        angular.forEach(['dragularenter', 'dragularleave', 'dragularrelease'], function prepareDragOverEvents(name) {\n\t          var eventName = o.eventNames[name];\n\t          if (!shared.dragOverEvents[eventName]){\n\t            if (doc.createEvent) {\n\t              shared.dragOverEvents[eventName] = doc.createEvent('HTMLEvents');\n\t              shared.dragOverEvents[eventName].initEvent(eventName, true, true);\n\t            } else {\n\t              shared.dragOverEvents[eventName] = doc.createEventObject();\n\t              shared.dragOverEvents[eventName].eventType = eventName;\n\t            }\n\t          }\n\t        });\n\t      }\n\t    }\n\n\t    // Event handlers functions (end of initial functions): -----------------------------------------------------------------------------------------------------------------\n\n\t    function grab(e) {\n\t      // filter some odd situations\n\t      if (whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey) {\n\t        return; // we only care about honest-to-god left clicks and touch events\n\t      }\n\n\t      // set itial values\n\t      shared.moveX = e.clientX;\n\t      shared.moveY = e.clientY;\n\n\t      var context = canStart(e.target);\n\t      if (!context || !context.item) {\n\t        return;\n\t      }\n\n\t      shared.grabbed = context;\n\t      eventualMovements();\n\t      if (e.type === 'mousedown') {\n\t        if (isInput(e.target)) { // see also: https://github.com/bevacqua/dragula/issues/208\n\t          e.target.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n\t          // changed from context.item to e.target fixing https://github.com/luckylooke/dragular/issues/87#issuecomment-256865796\n\t        } else {\n\t          e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n\t        }\n\t      }\n\t    }\n\n\t    function release(e) {\n\t      ungrab();\n\t      if (!drake.dragging) {\n\t        return;\n\t      }\n\t      if (e.originalEvent){\n\t          e = e.originalEvent; // jQuery enviroment\n\t      }\n\n\t      shared.clientX = getCoord('clientX', e);\n\t      shared.clientY = getCoord('clientY', e);\n\n\t      var elementBehindCursor = getElementBehindPoint(shared.mirror, shared.clientX, shared.clientY),\n\t        dropTarget = findDropTarget(elementBehindCursor, shared.clientX, shared.clientY);\n\n\t      if (dropTarget && ((shared.copy && g(o.copySortSource)) || (!shared.copy || dropTarget !== shared.source))) {\n\t        // found valid target and (is not copy case or target is not initial container)\n\t        drop(shared.item, dropTarget);\n\t      } else if (g(o.removeOnSpill)) {\n\t        remove();\n\t      } else {\n\t        cancel();\n\t      }\n\n\t      // after release there is no container hovered\n\t      shared.target = null;\n\n\t      if (shared.lastElementBehindCursor) {\n\t        fireEvent(shared.lastElementBehindCursor, shared.dragOverEvents.dragularrelease, elementBehindCursor);\n\t      }\n\n\t      if (o.scope) {\n\t        o.scope.$emit(o.eventNames.dragularrelease, shared.item, shared.source, e);\n\t      }\n\t    }\n\n\t    // Main logic functions (end of event handler functions): -----------------------------------------------------------------------------------------------------------------\n\n\t    function isContainer(el) {\n\t      if (!el){\n\t        return false;\n\t      }\n\t      var i = o.nameSpace.length;\n\t      while (i--) {\n\t        if (shared.containers[o.nameSpace[i]].indexOf(el) !== -1) {\n\t          return true;\n\t        }\n\t      }\n\t      if (o.isContainer(el)) {\n\t        shared.tempModel = o.isContainerModel(el);\n\t        return true;\n\t      } else {\n\t        shared.tempModel = null;\n\t      }\n\t      return false;\n\t    }\n\n\t    function getContainersModel(opt) {\n\t      return (typeof(opt.containersModel) === 'function') ? sanitizeContainersModel(opt.containersModel((opt === o ? drake : null), shared)) : opt.containersModel;\n\t    }\n\n\t    function removeContainers(all) {\n\t      $rootScope.$applyAsync(function applyDestroyed() {\n\t        var changes = Array.isArray(all) ? all : makeArray(all);\n\t        changes.forEach(function forEachContainer(container) {\n\t          angular.forEach(o.nameSpace, function forEachNs(nameSpace) {\n\t            var index;\n\t            index = shared.containers[nameSpace].indexOf(container);\n\t            shared.containers[nameSpace].splice(index, 1);\n\t            shared.containersCtx[nameSpace].splice(index, 1);\n\t          });\n\t        });\n\t      });\n\t    }\n\n\t    function eventualMovements(remove) {\n\t      var op = remove ? 'off' : 'on';\n\t      regEvent(docElm, op, 'mousemove', startBecauseMouseMoved);\n\t    }\n\n\t    function movements(remove) {\n\t      var op = remove ? 'off' : 'on';\n\t      regEvent(docElm, op, 'selectstart', preventGrabbed); // IE8\n\t      regEvent(docElm, op, 'click', preventGrabbed);\n\t      regEvent(docElm, op, 'touchmove', preventGrabbed); // fixes touch devices scrolling while drag\n\t    }\n\n\t    function destroy() {\n\t      registerEvents(true);\n\t      removeContainers(initialContainers);\n\t      release({});\n\t    }\n\n\t    function startBecauseMouseMoved(e) {\n\t      if (!shared.grabbed || drake.dragging) {\n\t        return;\n\t      }\n\t      if (e.originalEvent){\n\t          e = e.originalEvent; // jQuery enviroment\n\t      }\n\t      if (whichMouseButton(e) === 0) {\n\t        release({});\n\t        return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n\t      }\n\t      // truthy check fixes dragula-#239, equality fixes dragula-#207\n\t      if (e.clientX && e.clientX === shared.moveX && e.clientY && e.clientY === shared.moveY) {\n\t        return;\n\t      }\n\t      if (g(o.ignoreInputTextSelection)) {\n\t        var clientX = getCoord('clientX', e),\n\t          clientY = getCoord('clientY', e),\n\t          elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n\t        if (isInput(elementBehindCursor)) {\n\t          return;\n\t        }\n\t      }\n\n\t      var grabbed = shared.grabbed; // calling end() unsets shared.grabbed\n\t      eventualMovements('remove'); // remove mousemove listener\n\t      movements();\n\t      end();\n\t      start(grabbed);\n\t      if (!shared.item){ return; }\n\n\t      // automaticly detect direction of elements if not set in options\n\t      if (!o.direction && getParent(shared.sourceItem)) {\n\t        var parent = shared.sourceItem.parentNode,\n\t          parentHeight = parent.offsetHeight,\n\t          parentWidth = parent.offsetWidth,\n\t          childHeight = shared.sourceItem.clientHeight,\n\t          childWidth = shared.sourceItem.clientWidth;\n\t        o.direction = parentHeight / childHeight < parentWidth / childWidth ? 'horizontal' : 'vertical';\n\t      }\n\n\t      // get initial coordinates, used to render shared.mirror for first time\n\t      var offset = getOffset(shared.sourceItem);\n\t      shared.offsetX = getCoord('pageX', e) - offset.left;\n\t      shared.offsetY = getCoord('pageY', e) - offset.top;\n\t      shared.clientX = getCoord('clientX', e);\n\t      shared.clientY = getCoord('clientY', e);\n\n\t      // limiting area of shared.mirror movement, get initial coordinates\n\t      if (o.boundingBox) {\n\t        shared.offsetXr = getCoord('pageX', e) - offset.right;\n\t        shared.offsetYb = getCoord('pageY', e) - offset.bottom;\n\t      }\n\n\t      e.preventDefault();\n\n\t      renderMirrorImage();\n\t      addClass(shared.item, o.classes.transit);\n\t      // initial position\n\t      shared.mirror.style.left = shared.clientX - shared.offsetX + 'px';\n\t      shared.mirror.style.top = shared.clientY - shared.offsetY + 'px';\n\n\t      drag(e);\n\t    }\n\n\t    function canStart(item) {\n\t      if (drake.dragging && shared.mirror) {\n\t        console.log('usecase?');\n\t        return; // already dragging\n\t      }\n\n\t      var handle = item;\n\t      while (getParent(item) && !isContainer(getParent(item))) {\n\t        // break loop if user tries to drag item which is considered invalid handle\n\t        if (o.invalid(item, handle)) {\n\t          return;\n\t        }\n\t        item = getParent(item); // drag target should be immediate child of container\n\t        if (!item) {\n\t          return;\n\t        }\n\t      }\n\n\t      var source = getParent(item);\n\t      if (!source ||\n\t        o.invalid(item, handle) ||\n\t        !o.moves(item, source, handle, nextEl(item))) {\n\t        return;\n\t      }\n\n\t      return {\n\t        item: item,\n\t        source: source\n\t      };\n\t    }\n\n\t    function manualStart(item) {\n\t      var context = canStart(item);\n\t      if (context) {\n\t        shared.grabbed = context;\n\t        eventualMovements();\n\t        //start(context);\n\t      }\n\t    }\n\n\t    function start(context) {\n\t      shared.sourceItem = shared.item = context.item;\n\t      shared.source = context.source;\n\t      shared.initialSibling = shared.currentSibling = nextEl(context.item);\n\n\t      if (g(o.copy, [context.item, context.source])) {\n\t        shared.item = context.item.cloneNode(true);\n\t        shared.copy = true;\n\t        if (o.scope) {\n\t          o.scope.$emit(o.eventNames.dragularcloned, shared.item, context.item);\n\t        }\n\t      } else {\n\t        shared.copy = false;\n\t      }\n\n\t      // prepare models operations\n\t      var containerIndex = initialContainers.indexOf(context.source);\n\t      shared.sourceModel = getContainersModel(o)[containerIndex];\n\n\t      shared.sourceFilteredModel = o.containersFilteredModel[containerIndex];\n\t      shared.initialIndex = domIndexOf(context.item, context.source);\n\n\t      drake.dragging = true;\n\t      if (o.scope) {\n\t        o.scope.$emit(o.eventNames.dragulardrag, shared.sourceItem, shared.source);\n\t      }\n\n\t      return true;\n\t    }\n\n\t    function end() {\n\t      if (!drake.dragging || !shared.item) {\n\t        return;\n\t      }\n\t      drop(shared.item, getParent(shared.item));\n\t    }\n\n\t    function ungrab() {\n\t      shared.grabbed = false;\n\t      eventualMovements('remove');\n\t      movements('remove');\n\t    }\n\n\t    function drop(item, target) {\n\t      if (!item){ // https://github.com/luckylooke/dragular/issues/102\n\t        cleanup();\n\t        return;\n\t      }\n\t      var sourceItem = shared.sourceItem,\n\t          currentSibling = shared.currentSibling,\n\t          dropIndex = domIndexOf(item, target);\n\t        \n\t      if (shared.copy && target === shared.source && getParent(item) && g(o.copySortSource)) {\n\t        item.parentNode.removeChild(shared.sourceItem);\n\t      }\n\n\t      if (shared.sourceModel && !isInitialPlacement(target)) {\n\t        if (shared.targetCtx && shared.targetCtx.fm){ // target has filtered model\n\t          // convert index from index-in-filteredModel to index-in-model\n\t          dropIndex = shared.targetCtx.m.indexOf(shared.targetCtx.fm[dropIndex]);\n\t        }\n\t        if (shared.sourceFilteredModel){ // source has filtered model\n\t          // convert index from index-in-filteredModel to index-in-model\n\t          shared.initialIndex = shared.sourceModel.indexOf(shared.sourceFilteredModel[shared.initialIndex]);\n\t        }\n\t        $rootScope.$applyAsync(function applyDrop() {\n\t          if (!shared.sourceModel){\n\t              return;\n\t          }\n\t          if (target === shared.source) {\n\t            shared.sourceModel.splice(dropIndex, 0, shared.sourceModel.splice(shared.initialIndex, 1)[0]);\n\t          } else {\n\t            shared.dropElmModel = shared.copy && !o.dontCopyModel ? angular.copy(shared.sourceModel[shared.initialIndex]) : shared.sourceModel[shared.initialIndex];\n\n\t            if (!shared.tempModel) {\n\t              shared.targetModel = ( shared.targetCtx && shared.targetCtx.m ) || shared.sourceModel;\n\t            } else {\n\t              shared.targetModel = shared.tempModel;\n\t            }\n\t            \n\t            target.removeChild(item); // element must be removed for ngRepeat to apply correctly\n\n\t            if (!shared.copy) {\n\t              shared.sourceModel.splice(shared.initialIndex, 1);\n\t            }\n\n\t            if (shared.targetModel){\n\t                shared.targetModel.splice(dropIndex, 0, shared.dropElmModel);\n\t            }\n\t          }\n\n\t          // removing element, as protection against duplicates, angular ng-repeat will create new item according to model\n\t          if (getParent(item)) {\n\t            item.parentNode.removeChild(item);\n\t          }\n\n\t          afterDrop();\n\t        });\n\t      } else {\n\t        afterDrop();\n\t      }\n\n\t      function afterDrop() {\n\t        if (o.compileItemOnDrop){\n\t            var scope = angular.element(target).scope ? angular.element(target).scope() : o.scope;\n\t            if(scope){\n\t              scope.$applyAsync(function(){\n\t                  var content = $compile(shared.copy ? sourceItem.cloneNode(true) : sourceItem)(scope);\n\t                  if(item.parentNode === target){\n\t                      target.removeChild(item);\n\t                  }\n\t                  target.insertBefore(content[0], currentSibling);\n\t                  cleanup();\n\t              });\n\t            }\n\t        }\n\t        \n\t        if (o.scope) {\n\t          if (isInitialPlacement(target)) {\n\t            o.scope.$emit(o.eventNames.dragularcancel, item, shared.source, shared.sourceModel, shared.initialIndex);\n\t          } else {\n\t            o.scope.$emit(o.eventNames.dragulardrop, item, target, shared.source, shared.sourceModel, shared.initialIndex, shared.targetModel, dropIndex);\n\t          }\n\t        }\n\n\t        if (!o.compileItemOnDrop){\n\t          cleanup();\n\t        }\n\t      }\n\t    }\n\n\t    function remove() {\n\t      if (!drake.dragging) {\n\t        return;\n\t      }\n\t      var parent = getParent(shared.item);\n\n\t      if (parent) {\n\t        parent.removeChild(shared.item);\n\t      }\n\n\t      if (shared.sourceModel) {\n\t        $rootScope.$applyAsync(function removeModel() {\n\t          shared.sourceModel.splice(shared.initialIndex, 1);\n\t          cleanup();\n\t        });\n\t      }\n\n\t      if (o.scope) {\n\t        o.scope.$emit(shared.copy ? o.eventNames.dragularcancel : o.eventNames.dragularremove, shared.item, parent, shared.sourceModel, shared.initialIndex);\n\t      }\n\t      if (!shared.sourceModel) {\n\t        cleanup();\n\t      }\n\t    }\n\n\t    function cancel(revert) {\n\t      if (!drake.dragging) {\n\t        return;\n\t      }\n\t      var reverts = arguments.length > 0 ? revert : g(o.revertOnSpill),\n\t        parent = getParent(shared.item);\n\n\t      var initial = isInitialPlacement(parent);\n\t      if (!initial && !shared.copy && reverts) {\n\t        shared.source.insertBefore(shared.item, shared.initialSibling);\n\t      }\n\t      if (shared.sourceModel && !shared.copy && !reverts) {\n\t        drop(shared.item, parent);\n\t      } else if (o.scope) {\n\t        if (initial || reverts) {\n\t          o.scope.$emit(o.eventNames.dragularcancel, shared.item, shared.source, shared.sourceModel, shared.initialIndex);\n\t        }\n\t      }\n\n\t      if (!shared.sourceModel || shared.copy || reverts || initial) {\n\t        cleanup();\n\t      }\n\t    }\n\n\t    function cleanup() {\n\t      ungrab();\n\t      removeMirrorImage();\n\n\t      if (shared.item) {\n\t        rmClass(shared.item, o.classes.transit);\n\t      }\n\n\t      drake.dragging = false;\n\n\t      if (g(o.removeOnSpill) === true) {\n\t        spillOut();\n\t      }\n\n\t      if (o.scope) {\n\t        if (shared.lastDropTarget){\n\t         o.scope.$emit(o.eventNames.dragularout, shared.item, shared.lastDropTarget, shared.source);\n\t        }\n\t        o.scope.$emit(o.eventNames.dragulardragend, shared.item);\n\t      }\n\n\t      shared.source = shared.item = shared.sourceItem = shared.initialSibling = shared.currentSibling = shared.sourceModel = null;\n\t      shared.initialIndex = shared.currentIndex = shared.lastDropTarget = shared.tempModel = shared.targetModel = null;\n\t      shared.dropElmModel = shared.targetCtx = shared.copy = shared.moveX = shared.moveY = null;\n\t    }\n\n\t    // is item currently placed in original container and original position?\n\t    function isInitialPlacement(target, s) { // watch performance - running each move several times!\n\t      var sibling = s || (shared.mirror ? shared.currentSibling : nextEl(shared.item));\n\t      return target === shared.source && sibling === shared.initialSibling;\n\t    }\n\n\t    // find valid drop container\n\t    function findDropTarget(elementBehindCursor, clientX, clientY) {  // watch performance - running each move!\n\t      var target = elementBehindCursor,\n\t          targetCtx = null;\n\n\t      while (target && !accepted()) {\n\t        target = getParent(target);\n\t      }\n\t      shared.targetCtx = targetCtx || {};\n\t      return target;\n\n\t      function accepted() {\n\n\t        if (!isContainer(target)) { // is not droppable?\n\t          return false;\n\t        }\n\n\t        var immediate = getImmediateChild(target, elementBehindCursor),\n\t            reference = getReference(target, immediate, clientX, clientY),\n\t            initial = isInitialPlacement(target, reference),\n\t            i = o.nameSpace.length,\n\t            nameSpace;\n\n\t        while (i--) { // for each namespace\n\t            nameSpace = o.nameSpace[i];\n\t          if (shared.containers[nameSpace].indexOf(target) !== -1) {\n\t            targetCtx = getTargetCtx(nameSpace);\n\t            break;\n\t          }\n\t        }\n\n\t        // shared.target must be actual (used for scroll functionality)\n\t        shared.target = target;\n\n\t        if ( initial ){\n\n\t          return true; // accepts = true;\n\n\t        } else {\n\n\t            // try to find target in default set of containers\n\t            if (!targetCtx) {\n\t                targetCtx = getTargetCtx('dragularCommon');\n\t            }\n\n\t            // if found and containersModel is dynamic, retrieve model\n\t            if (targetCtx && typeof targetCtx.o.containersModel === 'function'){\n\t                // fix targetCtx.m(odel) for dynamic containersModel\n\t                targetCtx.m = getContainersModel(targetCtx.o)[targetCtx.o.initialContainers.indexOf(target)];\n\t            }\n\n\t            if ( targetCtx && // target container is defined via service or directive\n\t                targetCtx.o.accepts &&\n\t                !targetCtx.o.accepts(shared.item, target, shared.source, reference, shared.sourceModel, shared.initialIndex)){\n\n\t                return false;\n\n\t            } else if ( o.isContainer && // target container is recognized via o.isContainer\n\t                o.isContainerAccepts &&\n\t                !o.isContainerAccepts(shared.item, target, shared.source, reference, shared.sourceModel, shared.initialIndex)){\n\n\t                return false;\n\n\t            }\n\n\t\t        return !o.canBeAccepted || o.canBeAccepted(shared.item, target, shared.source, reference, shared.sourceModel, shared.initialIndex);\n\n\t        }\n\n\t      }\n\n\t      function getTargetCtx(nameSpace){\n\t          return shared.containersCtx[nameSpace][shared.containers[nameSpace].indexOf(target)];\n\t      }\n\t    }\n\n\t    function drag(e) { // watch performance - running each move!\n\t      if (!shared.mirror) {\n\t        return;\n\t      }\n\t      if (e.originalEvent){\n\t          e = e.originalEvent; // jQuery enviroment\n\t      }\n\n\t      // update coordinates\n\t      shared.clientX = getCoord('clientX', e);\n\t      shared.clientY = getCoord('clientY', e);\n\n\t      // count mirror coordiates\n\t      var x = shared.clientX - shared.offsetX,\n\t        y = shared.clientY - shared.offsetY,\n\t        pageX,\n\t        pageY,\n\t        offsetBox;\n\n\t      // fill extra properties if boundingBox is used\n\t      if (o.boundingBox) {\n\t        pageX = getCoord('pageX', e);\n\t        pageY = getCoord('pageY', e);\n\t        offsetBox = getOffset(o.boundingBox);\n\t      }\n\n\t      if (!o.lockY) {\n\t        if (!o.boundingBox || (pageX > offsetBox.left + shared.offsetX && pageX < offsetBox.right + shared.offsetXr)) {\n\t          shared.mirror.style.left = x + 'px';\n\t        } else if (o.boundingBox) { // check again in case user scrolled the view\n\t          if (pageX < offsetBox.left + shared.offsetX) {\n\t            shared.mirror.style.left = shared.clientX - (pageX - offsetBox.left) + 'px';\n\t          } else {\n\t            shared.mirror.style.left = shared.clientX - shared.mirrorWidth - (pageX - offsetBox.right) + 'px';\n\t          }\n\t        }\n\t      }\n\t      if (!o.lockX) {\n\t        if (!o.boundingBox || (pageY > offsetBox.top + shared.offsetY && pageY < offsetBox.bottom + shared.offsetYb)) {\n\t          shared.mirror.style.top = y + 'px';\n\t        } else if (o.boundingBox) { // check again in case user scrolled the view\n\t          if (pageY < offsetBox.top + shared.offsetY) {\n\t            shared.mirror.style.top = shared.clientY - (pageY - offsetBox.top) + 'px';\n\t          } else {\n\t            shared.mirror.style.top = shared.clientY - shared.mirrorHeight - (pageY - offsetBox.bottom) + 'px';\n\t          }\n\t        }\n\t      }\n\n\t      var elementBehindCursor = getElementBehindPoint(shared.mirror, shared.clientX, shared.clientY),\n\t        dropTarget = findDropTarget(elementBehindCursor, shared.clientX, shared.clientY),\n\t        changed = dropTarget !== shared.lastDropTarget;\n\n\t      if (elementBehindCursor !== shared.lastElementBehindCursor) {\n\t        fireEvent(elementBehindCursor, shared.dragOverEvents.dragularenter, !!dropTarget);\n\t        if (shared.lastElementBehindCursor) {\n\t          fireEvent(shared.lastElementBehindCursor, shared.dragOverEvents.dragularleave, elementBehindCursor);\n\t        }\n\t        shared.lastElementBehindCursor = elementBehindCursor;\n\t      }\n\n\t      if (changed) {\n\t        if (shared.lastDropTarget) {\n\t          moved('out');\n\t        }\n\t        shared.lastDropTarget = dropTarget;\n\t        moved('over');\n\t      }\n\n\t      // do not copy in same container\n\t      if (dropTarget === shared.source && shared.copy && !g(o.copySortSource)) {\n\t        if (getParent(shared.item)) {\n\t          shared.item.parentNode.removeChild(shared.item);\n\t        }\n\t        return;\n\t      }\n\n\t      var reference,\n\t        immediate = getImmediateChild(dropTarget, elementBehindCursor);\n\n\t      if (immediate !== null) {\n\t        reference = getReference(dropTarget, immediate, shared.clientX, shared.clientY);\n\t      } else if (g(o.revertOnSpill) === true && !shared.copy) {\n\t        // the case that mirror is not over valid target and reverting is on and copy is off\n\t        reference = shared.initialSibling;\n\t        dropTarget = shared.source;\n\t      } else {\n\t        // the case that mirror is not over valid target and removing is on or copy is on\n\t        if (shared.copy && getParent(shared.item)) {\n\t          // remove item or copy of item\n\t          shared.item.parentNode.removeChild(shared.item);\n\t        }\n\t        return;\n\t      }\n\n\t      if (reference === null ||\n\t        reference !== shared.item &&\n\t        reference !== nextEl(shared.item) &&\n\t        reference !== shared.currentSibling) {\n\t        // moving item/copy to new container from previous one\n\t        shared.currentSibling = reference;\n\n\t        dropTarget.insertBefore(shared.item, reference); // if reference is null item is inserted at the end\n\n\t        if (o.scope) {\n\t          o.scope.$emit(o.eventNames.dragularshadow, shared.item, dropTarget, e);\n\t        }\n\t      }\n\n\t      function moved(type) {\n\t        if (o.scope) {\n\t          o.scope.$emit(o.eventNames['dragular' + type], shared.item, shared.lastDropTarget, shared.source, e);\n\t        }\n\t        if (g(o.removeOnSpill) === true) {\n\t          type === 'over' ? spillOver() : spillOut();\n\t        }\n\t      }\n\t    }\n\n\t    function spillOver() {\n\t      rmClass(shared.item, o.classes.hide);\n\t    }\n\n\t    function spillOut() {\n\t      if (drake.dragging) {\n\t        addClass(shared.item, o.classes.hide);\n\t      }\n\t    }\n\n\t    function scrollContainer(e) {\n\t      if (shared.target) {\n\t        if (e.originalEvent){\n\t            e = e.originalEvent; // jQuery enviroment\n\t        }\n\t        var before = shared.target.scrollTop;\n\t        shared.target.scrollTop += e.deltaY;\n\t        // block scroll of the document when container can be scrolled\n\t        if (before !== shared.target.scrollTop) {\n\t          e.stopPropagation();\n\t          e.preventDefault();\n\t        }\n\t      }\n\t    }\n\n\t    function renderMirrorImage() {\n\t      if (shared.mirror) {\n\t        return;\n\t      }\n\t      var rect = shared.sourceItem.getBoundingClientRect();\n\t      shared.mirror = shared.sourceItem.cloneNode(true);\n\t      shared.mirrorWidth = rect.width;\n\t      shared.mirrorHeight = rect.height;\n\t      shared.mirror.style.width = getRectWidth(rect) + 'px';\n\t      shared.mirror.style.height = getRectHeight(rect) + 'px';\n\t      addClass(shared.mirror, o.classes.mirror);\n\t      o.mirrorContainer.appendChild(shared.mirror);\n\t      regEvent(docElm, 'on', 'mousemove', drag);\n\t      addClass(doc.body, o.classes.unselectable);\n\t      regEvent(shared.mirror, 'on', 'wheel', scrollContainer);\n\t      if (o.scope) {\n\t        o.scope.$emit(o.eventNames.dragularcloned, shared.mirror, shared.sourceItem);\n\t      }\n\t    }\n\n\t    function removeMirrorImage() {\n\t      if (shared.mirror) {\n\t        rmClass(doc.body, o.classes.unselectable);\n\t        regEvent(docElm, 'off', 'mousemove', drag);\n\t        regEvent(shared.mirror, 'off', 'wheel', scrollContainer);\n\t        if (getParent(shared.mirror)){\n\t          shared.mirror.parentNode.removeChild(shared.mirror);\n\t        }\n\t        shared.mirror = null;\n\t      }\n\t    }\n\n\t    function getImmediateChild(dropTarget, target) { // watch performance - running each move several times!\n\t      var immediate = target;\n\t      while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n\t        immediate = getParent(immediate);\n\t      }\n\t      if (immediate === docElm) {\n\t        return null;\n\t      }\n\t      return immediate;\n\t    }\n\n\t    function getReference(dropTarget, target, x, y) { // watch performance - running each move several times!\n\t      var horizontal = o.direction === 'horizontal';\n\t      return target !== dropTarget ? inside() : outside();\n\n\t      function outside() { // slower, but able to figure out any position\n\t        var len = dropTarget.children.length,\n\t          i, el, rect;\n\t        for (i = 0; i < len; i++) {\n\t          el = dropTarget.children[i];\n\t          rect = el.getBoundingClientRect();\n\t          if (horizontal && rect.left > x) {\n\t            return el;\n\t          }\n\t          if (!horizontal && rect.top > y) {\n\t            return el;\n\t          }\n\t        }\n\t        return null;\n\t      }\n\n\t      function inside() { // faster, but only available if dropped inside a child element\n\t        var rect = target.getBoundingClientRect();\n\t        if (horizontal) {\n\t          return resolve(x > rect.left + getRectWidth(rect) / 2);\n\t        }\n\t        return resolve(y > rect.top + getRectHeight(rect) / 2);\n\t      }\n\n\t      function resolve(after) {\n\t        return after ? nextEl(target) : target;\n\t      }\n\t    }\n\n\t    function getElementBehindPoint(point, x, y) { // watch performance - running each move!\n\t      var p = point || {},\n\t        state = p.className,\n\t        el;\n\t      p.className += ' ' + o.classes.hide;\n\t      el = doc.elementFromPoint(x, y);\n\t      p.className = state;\n\t      return el;\n\t    }\n\t  } // end of service\n\n\t  /****************************************************************************************************************************/\n\t  /****************************************************************************************************************************/\n\t  /****************************************************************************************************************************/\n\n\t  // HELPERS FUNCTIONS:\n\n\t  function regEvent(el, op, type, fn) {\n\t    var touch = {\n\t        mouseup: 'touchend',\n\t        mousedown: 'touchstart',\n\t        mousemove: 'touchmove'\n\t      },\n\t      pointers = {\n\t        mouseup: 'pointerup',\n\t        mousedown: 'pointerdown',\n\t        mousemove: 'pointermove'\n\t      },\n\t      microsoft = {\n\t        mouseup: 'MSPointerUp',\n\t        mousedown: 'MSPointerDown',\n\t        mousemove: 'MSPointerMove'\n\t      },\n\t      $el = angular.element(el);\n\n\t    if (el.addEventListener) {\n\n\t        var opConvert = { on: 'addEventListener', off: 'removeEventListener' };\n\t        el[ opConvert[ op ] ]( type, fn, { passive: false } );\n\t        el[ opConvert[ op ] ]( touch[ type ], fn, { passive: false } );\n\n\t    } else {\n\n\t      if (typeof navigator !== 'undefined' && navigator.pointerEnabled && pointers[type]) {\n\t        $el[op](pointers[type], fn);\n\t      } else if (typeof navigator !== 'undefined' && navigator.msPointerEnabled && microsoft[type]) {\n\t        $el[op](microsoft[type], fn);\n\t      } else if (touch[type]) {\n\t        $el[op](touch[type], fn);\n\t      }\n\t      $el[op](type, fn);\n\n\t    }\n\t  }\n\n\t  function never() {\n\t    return false;\n\t  }\n\n\t  function always() {\n\t    return true;\n\t  }\n\n\t  // make array from array-like objects or from single element (based on bevacqua/atoa)\n\t  function makeArray(all, startIndex) {\n\t    if (Array.isArray(all)) {\n\t      return all;\n\t    }\n\t    if (all.length) { // is array-like\n\t      return Array.prototype.slice.call(all, startIndex); // convert to vanilla js array\n\t    } else { // is one element\n\t      return [all];\n\t    }\n\t  }\n\n\t  function whichMouseButton (e) {\n\t    if (e.touches) { return e.touches.length; }\n\t    if (e.originalEvent && e.originalEvent.touches) { return e.originalEvent.touches.length; }\n\t    if (e.which !== void 0 && e.which !== 0) { return e.which; } // github.com/bevacqua/dragula/issues/261\n\t    if (e.buttons !== undefined) { return e.buttons; }\n\t    var button = e.button;\n\t    if (button !== undefined) { // see github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n\t      return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);\n\t    }\n\t  }\n\n\t  function preventGrabbed(e) {\n\t    if (e.originalEvent){\n\t        e = e.originalEvent; // jQuery enviroment\n\t    }\n\t    if (shared.grabbed) {\n\t      e.preventDefault();\n\t    }\n\t  }\n\n\t  function getScroll(scrollProp, offsetProp) {\n\t    if (typeof window[offsetProp] !== 'undefined') {\n\t      return window[offsetProp];\n\t    }\n\t    if (docElm.clientHeight) {\n\t      return docElm[scrollProp];\n\t    }\n\t    return doc.body[scrollProp];\n\t  }\n\n\t  function getOffset(el) { // watch performance - running each move!\n\t    var rect = el.getBoundingClientRect(),\n\t      scrollTop = getScroll('scrollTop', 'pageYOffset'),\n\t      scrollLeft = getScroll('scrollLeft', 'pageXOffset');\n\t    return {\n\t      left: rect.left + scrollLeft,\n\t      right: rect.right + scrollLeft,\n\t      top: rect.top + scrollTop,\n\t      bottom: rect.bottom + scrollTop\n\t    };\n\t  }\n\n\t  function getRectWidth(rect) {\n\t    return rect.width || (rect.right - rect.left);\n\t  }\n\n\t  function getRectHeight(rect) {\n\t    return rect.height || (rect.bottom - rect.top);\n\t  }\n\n\t  function getEmptyObject() {\n\t    return {};\n\t  }\n\n\t  function nextEl(el) {\n\t    if (!el){ // https://github.com/luckylooke/dragular/issues/102\n\t      return;\n\t    }\n\t    return el.nextElementSibling || manually();\n\n\t    function manually() {\n\t      var sibling = el;\n\t      do {\n\t        sibling = sibling.nextSibling;\n\t      } while (sibling && sibling.nodeType !== 1);\n\t      return sibling;\n\t    }\n\t  }\n\n\t  //Cannot use angular.isElement because we need to check plain dom element, no jQlite wrapped\n\t  function isElement(obj) {\n\t    return (\n\t      typeof HTMLElement === 'object' ? obj instanceof HTMLElement : //DOM2\n\t      obj && typeof obj === 'object' && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === 'string'\n\t    );\n\t  }\n\n\t  function lookupClass(className) {\n\t    var cached = shared.classesCache[className];\n\t    if (cached) {\n\t      cached.lastIndex = 0;\n\t    } else {\n\t      shared.classesCache[className] = cached = new RegExp('(?:^|\\\\s)' + className + '(?:\\\\s|$)', 'g');\n\t    }\n\t    return cached;\n\t  }\n\n\t  function addClass(el, className) {\n\t    var current = el.className;\n\t    if (!current.length) {\n\t      el.className = className;\n\t    } else if (!lookupClass(className).test(current)) {\n\t      el.className += ' ' + className;\n\t    }\n\t  }\n\n\t  function rmClass(el, className) {\n\t    el.className = el.className.replace(lookupClass(className), ' ').trim();\n\t  }\n\n\t  function getEventHost(e) {\n\t    // on touchend event, we have to use `e.changedTouches`\n\t    // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n\t    // see https://github.com/bevacqua/dragula/issues/34\n\t    if (e.targetTouches && e.targetTouches.length) {\n\t      return e.targetTouches[0];\n\t    }\n\t    if (e.changedTouches && e.changedTouches.length) {\n\t      return e.changedTouches[0];\n\t    }\n\t    return e;\n\t  }\n\n\t  function getCoord(coord, e) { // watch performance - running each move several times!\n\t    var host = getEventHost(e);\n\t    var missMap = {\n\t      pageX: 'clientX', // IE8\n\t      pageY: 'clientY' // IE8\n\t    };\n\t    if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n\t      coord = missMap[coord];\n\t    }\n\n\t    // Adding support for touch events, as they are not functional in the original\n\t    if (!host.type || host.type.indexOf('touch') < 0) {\n\t      return host[coord];\n\t    } else {\n\t      if (host.type.indexOf('end') === -1) {\n\t        // No clientX or clientY in a touch event\n\t        return host.originalEvent.touches[0][coord.replace('client', 'page')];\n\t      }\n\t      // Nothing should happen for touchend\n\t      return false;\n\t    }\n\t  }\n\n\t  function getParent (el) { // watch performance - running each move!\n\t    return el.parentNode === document ? null : el.parentNode;\n\t  }\n\n\t  function isInput (el) {\n\t    return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el);\n\t  }\n\n\t  function isEditable (el) {\n\t    if (!el) { return false; } // no parents were editable\n\t    if (el.contentEditable === 'false') { return false; } // stop the lookup\n\t    if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain\n\t    return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n\t  }\n\n\t  function domIndexOf(child, parent) {\n\t    return Array.prototype.indexOf.call(angular.element(parent).children(), child);\n\t  }\n\n\t  function fireEvent(target, e, extra) { // watch performance - running each move!\n\t    if (!target) {\n\t      return;\n\t    }\n\t    shared.extra = extra;\n\t    if (target.dispatchEvent) {\n\t      target.dispatchEvent(e);\n\t    } else {\n\t      target.fireEvent('on' + e.eventType, e);\n\t    }\n\t  }\n\n\t  function getBool(prop, args, context){\n\t    if (angular.isFunction(prop)){\n\t      return !!prop.apply(context || this, args || shared);\n\t    }else{\n\t      return !!prop;\n\t    }\n\t  }\n\n\t};\n\n\tdragularService.$inject = ['$rootScope', '$compile'];\n\n\tmodule.exports = dragularService;\n\n\n/***/ }\n/******/ ])\n});\n;"]}